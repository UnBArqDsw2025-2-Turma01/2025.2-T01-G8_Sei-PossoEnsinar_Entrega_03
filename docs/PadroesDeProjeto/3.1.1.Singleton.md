# 3.1.1. Singleton

## Introdução

Este documento tem como objetivo apresentar a aplicação do padrão de projeto **Singleton**, um dos padrões **GoF (Gang of Four)**, no contexto do sistema **Sei&PossoEnsinar**. 

O padrão Singleton é utilizado para garantir que uma classe tenha apenas uma instância e fornecer um ponto de acesso global a ela. É frequentemente aplicado em casos onde componentes únicos da aplicação precisam ser compartilhados por diferentes partes do sistema.

---

## Metodologia

Com base no escopo do sistema e nos diagramas de sequência e classes fornecidos, foram analisadas diversas áreas em que a aplicação do padrão Singleton seria pertinente. 

A avaliação considerou critérios como:
- Centralização de controle  
- Necessidade de uma única fonte de verdade  
- Reutilização de instâncias compartilhadas  

Durante o processo de análise, foram considerados os seguintes candidatos ao uso de Singleton no projeto **Sei&PossoEnsinar**:

- Gerenciador de Conexão com o Banco de Dados  
- Serviço de Configuração Global  
- Serviço de Logging  
- Serviço de Notificação (para centralizar os envios de e-mail e push vistos no fluxo *"Atender Solicitações"*)  
- Gerenciador de Cache (para perfis de Monitor ou Habilidades)

Dentre esses, o **Gerenciador de Conexão com o Banco de Dados** foi selecionado como exemplo prático neste documento por ser um caso clássico de uso de Singleton, permitindo a gestão eficiente e segura de conexões com o banco em aplicações web.

---

## Desenvolvimento

No projeto **Sei&PossoEnsinar**, o padrão Singleton foi aplicado para gerenciar o *pool* de conexões com o banco de dados, garantindo que toda a aplicação utilize uma única instância desse serviço. Isso evita desperdício de recursos e garante integridade nas operações de acesso ao banco.

A implementação foi feita utilizando o **framework NestJS**, que já provê, por padrão, o comportamento singleton para seus provedores (*services*) quando registrados em módulos. 

O serviço `DatabaseConnectionPoolService` simula um *pool* de conexões e é disponibilizado globalmente pelo `DatabaseModule`, anotado com `@Global()`.

---

### Estrutura do Singleton no Projeto

#### Serviço Singleton
O arquivo `database-connection-pool.service.ts` define o serviço do *pool* de conexões. Ele possui um `instanceId` gerado no construtor para demonstrar que apenas uma instância é criada durante todo o ciclo de vida da aplicação.

#### Módulo Global
O arquivo `database.module.ts` registra o serviço como global, tornando-o acessível em qualquer parte da aplicação.

#### Consumidores do Singleton
Serviços como:
- Serviço de Materiais  
- Serviço de Habilidades  
- Serviços de Backend (responsável por atender solicitações)  

recebem o `DatabaseConnectionPoolService` via injeção de dependência.  
Todos compartilham a mesma instância, comprovada pelo mesmo `instanceId` nos logs.

---

## Código Aplicado (TypeScript)

```typescript
// /src/database/database-connection-pool.service.ts
import { Injectable, OnModuleInit, Logger } from "@nestjs/common";

@Injectable()
export class DatabaseConnectionPoolService implements OnModuleInit {
  private readonly logger = new Logger(DatabaseConnectionPoolService.name);
  private connections: string[] = [];
  private readonly MAX_CONNECTIONS = 5;
  private instanceId: string;

  constructor() {
    this.instanceId = Math.random().toString(36).substring(2, 15);
    this.logger.log(
      `DatabaseConnectionPoolService instance CREATED (ID: ${this.instanceId})`
    );
    this.initializePool();
  }

  onModuleInit() {
    this.logger.log(
      `DatabaseConnectionPoolService (ID: ${this.instanceId}) has been initialized.`
    );
  }

  private initializePool() {
    for (let i = 0; i < this.MAX_CONNECTIONS; i++) {
      this.connections.push(`mock_connection_${i + 1}_idle`);
    }
    this.logger.log(
      `Connection pool initialized with ${this.connections.length} mock connections by instance ID: ${this.instanceId}`
    );
  }

  getConnection(): string | null {
    const availableConnection = this.connections.find((conn) =>
      conn.endsWith("_idle")
    );

    if (availableConnection) {
      const connIndex = this.connections.indexOf(availableConnection);
      this.connections[connIndex] = availableConnection.replace(
        "_idle",
        "_active"
      );
      this.logger.log(
        `[Instance ID: ${this.instanceId}] Connection '${this.connections[connIndex]}' acquired.`
      );
      this.printPoolStatus();
      return this.connections[connIndex];
    }

    this.logger.warn(
      `[Instance ID: ${this.instanceId}] No idle connections available. Pool is full.`
    );
    this.printPoolStatus();
    return null;
  }

  releaseConnection(connectionName: string): void {
    const connIndex = this.connections.findIndex(
      (conn) => conn === connectionName && conn.endsWith("_active")
    );

    if (connIndex !== -1) {
      this.connections[connIndex] = this.connections[connIndex].replace(
        "_active",
        "_idle"
      );
      this.logger.log(
        `[Instance ID: ${this.instanceId}] Connection '${connectionName}' released.`
      );
      this.printPoolStatus();
    } else {
      this.logger.warn(
        `[Instance ID: ${this.instanceId}] Attempted to release an invalid or already idle connection: ${connectionName}`
      );
    }
  }

  private printPoolStatus(): void {
    const activeCount = this.connections.filter((conn) =>
      conn.endsWith("_active")
    ).length;
    const idleCount = this.connections.filter((conn) =>
      conn.endsWith("_idle")
    ).length;
    this.logger.log(
      `[Instance ID: ${this.instanceId}] Pool Status: Active = ${activeCount}, Idle = ${idleCount}`
    );
  }

  getPoolInstanceId(): string {
    return this.instanceId;
  }
}

``` 
## Figura 1

**Diagrama de classes representando o padrão Singleton (GoF)**  
![Figura 1: Diagrama Singleton](../images/DiagramaSingleton.png)

*Autor: Pedro Camilo, 2025.*

---

## Demonstração do Código sendo Executado

**Participantes:** João Victor e Pedro Camilo   

[Link do vídeo](https://youtu.be/kw3CUrdgBhg)

---

## Conclusão

A aplicação do padrão **Singleton** no serviço de *pool* de conexões do projeto **Sei&PossoEnsinar** permitiu centralizar e otimizar o uso de recursos, garantindo que toda a aplicação utilize uma única instância para gerenciar as conexões ao banco de dados. 

Com o suporte do **NestJS**, a implementação foi simples e transparente, assegurando eficiência, integridade e facilidade de manutenção ao compartilhar a mesma instância entre diferentes módulos e serviços do sistema.

---

## Bibliografia

- **Refactoring Guru.** *Singleton.* Disponível em: [https://refactoring.guru/pt-br/design-patterns/singleton](https://refactoring.guru/pt-br/design-patterns/singleton). Acesso em: 23 outubro 2025.  
- **SERRANO, Milene.** *AULA - GOFS CRIACIONAIS.* Slides. Universidade de Brasília, 2025. Acesso em: 23 outubro 2025.  
- **GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John.** *Design Patterns: Elements of Reusable Object-Oriented Software.* Addison-Wesley, 1994.  
- **NESTJS.** *Official Documentation.* Disponível em: [https://docs.nestjs.com](https://docs.nestjs.com)  
- **POSTGRESQL.** *Node.js and PostgreSQL.* Disponível em: [https://node-postgres.com](https://node-postgres.com)

---

## Histórico de Versões

| Versão | Data       | Descrição                                                                                             | Autor(es)              | Revisor(es) |
|:------:|:-----------:|:------------------------------------------------------------------------------------------------------|:-----------------------|:-------------|
| 1.0    | 23/10/2025  | Criação do documento  | [Pedro Camilo](https://github.com/PedrooCamilo), [João Victor](https://github.com/joaofmoreiraa)     |        |
