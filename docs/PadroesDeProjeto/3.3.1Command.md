# 3.3.1. Command

## Introdução

Este documento detalha a aplicação do padrão de projeto Command (Comando) – um dos padrões Comportamentais do Gang of Four (GoF) – no sistema de gerenciamento de sessões de ensino. O objetivo central do padrão Command é encapsular uma chamada de método como um objeto. Essa técnica converte solicitações ou operações em objetos autocontidos, permitindo que as requisições sejam manipuladas de maneira flexível, suportando funcionalidades avançadas como a organização de filas de tarefas, o registro de histórico de ações (log) e a implementação de operações de desfazer (undo).

No contexto deste projeto, o padrão Command é implementado para formalizar e desacoplar as interações do Aluno com os serviços do sistema. Ao encapsular ações como "Buscar Monitor" ou "Acessar Material" em objetos de comando, o painel de controle do Aluno pode gerenciar e executar essas requisições de forma uniforme, sem a necessidade de conhecer a lógica de negócio subjacente.

-----

## Metodologia

A implementação do padrão Command foi realizada seguindo as melhores práticas de design orientado a objetos:

1. Mapeamento de Ações: Análise das interações primárias do Aluno com o sistema para identificar ações que poderiam ser tratadas de forma assíncrona ou enfileirada. As ações buscarMonitor e acessarMateriais foram escolhidas como Comandos Concretos.
2. Estrutura de Componentes: Definição dos quatro papéis essenciais do padrão:
3. Command: Interface AcaoAluno (o contrato).
4. Concrete Command: Classes BuscarMonitorComando e AcessarMonitorComando.
5. Receiver: Classe ServicoAluno (o executor da lógica).
6. Invoker: Classe PainelAluno (o disparador das ações).
7. Desenho UML: Criação do diagrama de classes (conforme a imagem fornecida) para visualizar o fluxo, enfatizando as relações de dependência e agregação (o PainelAluno agrega a AcaoAluno).

-----

## Desenvolvimento

O padrão Command foi aplicado para criar um mecanismo robusto e extensível para o Painel do Aluno, separando a intenção da ação da execução da ação.

**Estrutura do Encapsulamento de Ações**

O diagrama de classes ilustra como a requisição do Aluno é transformada em uma estrutura de objetos:

| Papel do Padrão     | Entidade no Diagrama                        | Responsabilidade no Projeto                                                                                                                                                                                                                                                       |
| :------------------ | :------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Command (Interface) | <<Interface>> AcaoAluno                     | Contrato que define o método universal para iniciar qualquer ação: + executar().                                                                                                                                                                                                  |
| Concrete Commands   | BuscarMonitorComando, AcessarMonitorComando | Encapsulamento da Requisição: Cada classe empacota o Receptor (ServicoAluno), o Cliente (Aluno) e os parâmetros específicos. O método executar() simplesmente chama o método apropriado no Receptor, traduzindo o comando.                                                        |
| Receiver (Receptor) | ServicoAluno                                | Lógica de Negócio: Contém o conhecimento e os métodos reais para realizar as operações de backend (+ buscarMonitor(habilidade: String), + acessarMaterial(id: int)). O Receptor é desacoplado do Invocador e dos Comandos.                                                        |
| Invoker (Invocador) | PainelAluno                                 | Gerenciamento do Comando: Contém a lista de comandos (listaComandos: List<AcaoAluno>) e o método genérico + executarAcoes(). O Invocador não sabe, e nem precisa saber, o que AcessarMonitorComando ou BuscarMonitorComando fazem; apenas sabe que pode chamá-los via executar(). |
| Cliente             | Aluno                                       | Criação e Configuração: O Aluno é o componente que, a partir de suas próprias requisições (+ acessarMateriais(), + buscarMonitor()), cria as instâncias concretas dos Comandos e as passa para o PainelAluno (Invocador).                                                         |


-----

### Diagrama

<font size="2"><p style="text-align: center"><b>Figura 1:</b> Diagrama de Classes do padrão Command</p></font>

<div style="text-align: center;">

![proxy](../images/DiagramaCommand.png)

</div>

<font size="2"><p style="text-align: center"><b>Autor:</b> <a href="https://github.com/leanars">Bruno Cruz e Anne de Capdeville</a>, 2025</p></font>


-----
### Código

#### AcaoAluno

```
public interface AcaoAluno {
    void executar();
}

```
#### ServicoAluno

```
public class ServicoAluno {

    public void buscarMonitor(int alunoId, String habilidade) {
        System.out.println("   [RECEIVER: ServicoAluno] Aluno ID " + alunoId + ": Iniciando busca por Monitor...");
        System.out.println("   [RECEIVER: ServicoAluno] Busca concluida para habilidade: " + habilidade);
    }

    public void acessarMaterial(int alunoId, int idMaterial) {
        System.out.println("   [RECEIVER: ServicoAluno] Aluno ID " + alunoId + ": Verificando permissao e acessando Material ID " + idMaterial);
        System.out.println("   [RECEIVER: ServicoAluno] Material ID " + idMaterial + " acessado com sucesso.");
    }
}

```

#### Aluno

```
public class Aluno {
    
    private final int idAluno;

    public Aluno(int idAluno) {
        this.idAluno = idAluno;
    }

    public void acessarMateriais(PainelAluno painel, ServicoAluno servico, int idMaterial) {
        AcaoAluno comando = new AcessarMaterialComando(this, servico, idMaterial);
        painel.adicionarComando(comando);
    }

    public void buscarMonitor(PainelAluno painel, ServicoAluno servico, String habilidade) {
        AcaoAluno comando = new BuscarMonitorComando(this, servico, habilidade);
        painel.adicionarComando(comando);
    }

    public int getIdAluno() {
        return idAluno;
    }
}

```

#### BuscarMonitorComando

```
public class BuscarMonitorComando implements AcaoAluno {

    private final Aluno aluno;
    private final ServicoAluno servico; // O Receiver
    private final String habilidade;

    public BuscarMonitorComando(Aluno aluno, ServicoAluno servico, String habilidade) {
        this.aluno = aluno;
        this.servico = servico;
        this.habilidade = habilidade;
    }

    @Override
    public void executar() {
        System.out.println("\n[COMANDO: BuscarMonitor] Encapsulando e disparando a busca por: " + habilidade);
        servico.buscarMonitor(aluno.getIdAluno(), habilidade);
    }
}

```

#### AcessarMaterialComando

```
public class AcessarMaterialComando implements AcaoAluno {
    
    private final Aluno aluno;
    private final ServicoAluno servico; // O Receiver
    private final int idMaterial;
    
    public AcessarMaterialComando(Aluno aluno, ServicoAluno servico, int idMaterial) {
        this.aluno = aluno;
        this.servico = servico;
        this.idMaterial = idMaterial;
    }

    @Override
    public void executar() {
        System.out.println("\n[COMANDO: AcessarMaterial] Encapsulando e disparando acesso ao Material ID: " + idMaterial);
        servico.acessarMaterial(aluno.getIdAluno(), idMaterial);
    }
}
```

#### PainelAluno

```
import java.util.ArrayList;
import java.util.List;

public class PainelAluno {
    
    private final List<AcaoAluno> listaComandos = new ArrayList<>();

    public void adicionarComando(AcaoAluno comando) {
        System.out.println("[INVOKER: PainelAluno] Comando adicionado a fila.");
        listaComandos.add(comando);
    }
    
    public void executarAcoes() {
        System.out.println("\n*** INVOKER INICIANDO EXECUCAO DE AÇOES PENDENTES ***");
        for (AcaoAluno comando : listaComandos) {
            comando.executar(); 
        }
        System.out.println("*** FILA DE EXECUCAO CONCLUIDA ***");
        listaComandos.clear();
    }
}

```

#### Aplicacao (Main)

```
public class Aplicacao {

    public static void main(String[] args) {
        System.out.println("==============================================");
        System.out.println("--- DEMONSTRACAO DO COMMAND (GOF) ---");
        System.out.println("==============================================");

        ServicoAluno servico = new ServicoAluno();

        PainelAluno painel = new PainelAluno();

        Aluno aluno = new Aluno(1001);

        System.out.println("\n--- ALUNO PARAMETRIZANDO ACOES ---");
        
        aluno.buscarMonitor(painel, servico, "Java");
        aluno.acessarMateriais(painel, servico, 45); 
        aluno.buscarMonitor(painel, servico, "Proxy/Bridge"); 
        
        // Invoker executa a fila de comandos.
        painel.executarAcoes();

        System.out.println("\n--- FIM ---");
        System.out.println("O Invoker executou acoes variadas de forma desacoplada do Aluno e do ServicoAluno.");
    }
}

```

-----

## Histórico de Versões

| Versão | Data       | Descrição                          | Autor(es)                       | Revisor(es)        |
| :----- | :--------- | :--------------------------------- | :------------------------------ | :----------------- |
| 1.0    | 24/10/2025 | Criação da documentação            | Anne de Capdeville              | Bruno Cruz         |
| 1.1    | 24/10/2025 | Documentação e criação do diagrama | Anne de Capdeville e Bruno Cruz | Bruno Cruz         |
| 1.2    | 24/10/2025 | Adição dos códigos                 | Anne de Capdeville e Bruno Cruz | Anne de Capdeville |
