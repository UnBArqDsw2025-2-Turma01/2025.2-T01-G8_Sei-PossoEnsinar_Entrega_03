
# 3.2.3. Composite

## Introdução

O **Composite** é um padrão estrutural que permite compor objetos em árvores para representar hierarquias parte-todo. Com ele, objetos simples (folhas) e compostos podem ser tratados de forma uniforme.[7]

## Contexto no Sei&PossoEnsinar

Na plataforma, conteúdos como cursos, módulos, seções e aulas podem ser organizados hierarquicamente, facilitando cálculo de duração, progresso e manipulação uniforme dessa árvore.

## Estrutura

<img width="516" height="415" alt="image" src="https://github.com/user-attachments/assets/b683c944-5cea-4136-94e0-fdf50b1d5fa0" />


## Implementação em C#

```csharp
// Componente base abstrato
public abstract class ComponenteCurriculum
{
    public string Titulo { get; }
    protected ComponenteCurriculum(string titulo) { Titulo = titulo; }
    public abstract int GetDuracao();
    public abstract void Exibir(int nivel = 0);
    public virtual void Adicionar(ComponenteCurriculum comp) => 
        throw new NotSupportedException();
    public virtual void Remover(ComponenteCurriculum comp) =>
        throw new NotSupportedException();
}

// Folha: Aula, Artigo, Exercício etc.
public class ItemCurriculum : ComponenteCurriculum
{
    private int duracao;
    public ItemCurriculum(string titulo, int duracaoMin) : base(titulo) { duracao = duracaoMin; }
    public override int GetDuracao() => duracao;
    public override void Exibir(int nivel = 0)
    {
        Console.WriteLine($"{new string(' ', nivel * 2)}- {Titulo} ({duracao} min)");
    }
}

// Composite: Curso, Módulo, Seção etc.
public class ComposicaoCurriculum : ComponenteCurriculum
{
    private List<ComponenteCurriculum> filhos = new();
    public ComposicaoCurriculum(string titulo) : base(titulo) { }
    public override int GetDuracao() => filhos.Sum(f => f.GetDuracao());
    public override void Exibir(int nivel = 0)
    {
        Console.WriteLine($"{new string(' ', nivel * 2)}+ {Titulo} ({GetDuracao()} min)");
        foreach (var c in filhos) c.Exibir(nivel + 1);
    }
    public override void Adicionar(ComponenteCurriculum comp) => filhos.Add(comp);
    public override void Remover(ComponenteCurriculum comp) => filhos.Remove(comp);
}
```

## Exemplo de Uso

```csharp
var curso = new ComposicaoCurriculum("C# Essencial");
var modulo1 = new ComposicaoCurriculum("Fundamentos");
modulo1.Adicionar(new ItemCurriculum("Introdução", 10));
modulo1.Adicionar(new ItemCurriculum("Tipos de dados", 20));
curso.Adicionar(modulo1);
curso.Adicionar(new ItemCurriculum("Encerramento", 5));
curso.Exibir(); // Mostra árvore - tratamento uniforme
```

## Vantagens

- Permite tratar objetos individuais e composições da mesma forma.[2]
- Suporta estruturas recursivas e operações agregadas (ex: duração total, progresso).
- Facilita extensibilidade dos tipos de nós (novos tipos de conteúdo).

## Desvantagens

- Pode adicionar complexidade para hierarquias simples.
- Implementações genéricas (como Add/Remove) podem lançar exceção em folhas.[5]

## Quando Usar

- Quando é necessário representar hierarquias parte-todo.
- Quando deseja-se aplicar operações uniformemente entre folhas e composições.[3]

***

| Versão | Data | Descrição | Autor(es) | Revisor(es) |
| :--- | :--- | :--- | :--- | :--- |
| 1.0 | 24/10/2025 | Criação da documentação  | Victor Câmara e Maria Eduarda|         |
