# 3.3.4. State

## Introdução

Com o objetivo de criar uma plataforma de monitoria acadêmica robusta e de fácil manutenção, o sistema **Sei&PossoEnsinar** está sendo desenvolvido utilizando boas práticas de arquitetura de software e padrões de projeto GoF (Gang of Four). Dentre eles, destaca-se o uso do padrão comportamental **State** para a gestão do ciclo de vida das sessões de monitoria.

A aplicação do padrão State surgiu da necessidade de encapsular os diferentes comportamentos de uma `Sessao` com base em seu estado atual — como `Solicitada`, `Agendada`, `Concluida` ou `Cancelada`. Isso permitiu que a entidade `Sessao` se mantivesse limpa, livre de condicionais complexas (`if`/`switch`), e facilitou a manutenção e futuras extensões do fluxo de agendamento.

## Metodologia

A metodologia adotada para a implementação do padrão **GoF State** seguiu uma abordagem orientada a objetos, alinhada a uma arquitetura em camadas e baseada nos princípios SOLID, especialmente:

* **Single Responsibility Principle (SRP)**: Cada classe de estado (ex: `EstadoSolicitada`) tem uma única responsabilidade: gerenciar o comportamento da sessão *naquele* estado específico.
* **Open/Closed Principle (OCP)**: O sistema é aberto para extensão (novos estados, como `EstadoEmRemarcacao`, podem ser adicionados) mas fechado para modificação (não é preciso alterar a classe `Sessao` ou os estados existentes para adicionar um novo).

### 1. Análise do Domínio

No contexto do **Sei&PossoEnsinar**, identificamos que uma `Sessao` passa por diferentes estados em seu ciclo de vida. Essas transições e regras de negócio foram levantadas a partir da [Modelagem de Casos de Uso](https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G8_Sei-PossoEnsinar_Entrega_02/#/Modelagem/2.3.1.ModelagemCasosDeUso) do sistema.

Os estados principais do ciclo de vida da `Sessao` são:

* **Solicitada**: (Originada de UC6 - Solicitar Sessão) O `Aluno` requisitou a sessão, que aguarda a aprovação do `Monitor`.
* **Agendada**: (Originada de UC13 - Atender Solicitações e UC7 - Definir Horário) O `Monitor` aceitou a solicitação.
* **Concluida**: A sessão de monitoria ocorreu (estado final do fluxo principal).
* **Cancelada**: A sessão foi recusada (UC13) ou cancelada por uma das partes.

Cada estado apresenta regras de negócio distintas para as ações possíveis, que se relacionam diretamente com os Casos de Uso:

* **`aceitar()` / `recusar()`**: Correspondem ao **UC13 - Atender Solicitações**.
* **`cancelar()`**: Ação de usuário (Aluno/Monitor) não especificada em uma UC, mas necessária ao fluxo.
* **`concluir()`**: Ação do Monitor/Sistema para finalizar a sessão.
* **`enviarMensagem()`**: Corresponde ao **UC8 - Tirar Dúvidas**.
* **`avaliar()`**: Corresponde ao **UC10 - Avaliar Sessões Concluídas**.

Por exemplo:
* A ação `avaliar()` (UC10) só é permitida no estado `Concluida`.
* A ação `aceitar()` (UC13) só é permitida no estado `Solicitada`.
* A ação `enviarMensagem()` (UC8) só é permitida no estado `Agendada`.

Essa variação de comportamento com base no estado é a indicação clássica para a aplicação do padrão **State**, evitando que a entidade `Sessao` acumule essa lógica condicional.

### 2. Modelagem do Padrão State

O padrão **State** foi modelado com três componentes centrais:

#### a) Interface `EstadoSessao`
Define um contrato comum para todas as ações cujo comportamento varia conforme o estado da sessão. Os métodos recebem o Contexto (`Sessao`) como parâmetro para permitir que os estados controlem a transição:
* `aceitar(Sessao sessao)`
* `recusar(Sessao sessao)`
* `cancelar(Sessao sessao)`
* `concluir(Sessao sessao)`
* `avaliar(Sessao sessao, ...)`
* `enviarMensagem(Sessao sessao, ...)`

#### b) Classes Concretas de Estado
Implementações específicas da interface `EstadoSessao` para cada estado:
* `EstadoSolicitada`
* `EstadoAgendada`
* `EstadoConcluida`
* `EstadoCancelada`

Cada classe encapsula sua própria lógica. Por exemplo, o método `aceitar()` em `EstadoSolicitada` executará a lógica de agendamento e mudará o estado da sessão para `EstadoAgendada`, enquanto o mesmo método em `EstadoAgendada` lançará uma exceção, pois a ação é inválida.

#### c) Classe Contexto: `Sessao`
É a entidade principal do domínio. Ela armazena a referência ao seu estado atual (via interface `EstadoSessao`) e delega todas as chamadas de ação para o objeto de estado. A `Sessao` não sabe *qual* estado concreto está ativo, apenas que ele implementa o contrato.

### 3. Decisões de Projeto

* **Separação entre estado e lógica de negócio**: A entidade `Sessao` (Contexto) não precisa saber "como" cada estado funciona — apenas delegar a chamada.
* **Flexibilidade para extensão futura**: Novos estados (ex: "Aguardando Pagamento") podem ser adicionados sem alterar o código existente.
* **Mudança dinâmica de comportamento**: O estado é trocado em tempo de execução pelos próprios objetos de estado, através do método `mudarEstado()` do Contexto.

### 4. Integração com a Arquitetura em Camadas

* **Camada de Domínio**: Residem a entidade `Sessao`, a interface `EstadoSessao` e os estados concretos.
* **Camada de Aplicação**: O `SessaoService` (serviço de aplicação) orquestra as ações. Ele carrega a entidade `Sessao` do repositório, chama o método de ação (ex: `sessao.aceitar()`), e o padrão State cuida da lógica interna. O serviço não conhece os estados concretos.
* **Camada de Infraestrutura**: O Repositório persiste a `Sessao`. Para salvar o estado, é comum usar um `enum` (ex: `StatusSessao`) no banco. Ao carregar a `Sessao`, o repositório instancia o objeto de estado concreto correspondente ao `enum` salvo.

## Diagrama do GoF State

<div style="text-align: center;">

![Diagrama state](../images/Diagrama-state.png)

<font size="2"><p style="text-align: center"><b>Autor:</b> Yan Guimarães, 2025.</p></font>
</div>

## Código (Implementação em C#)

A seguir está a estrutura de código em C# (.NET) que implementa o padrão State, seguindo a arquitetura em camadas (Domínio, Aplicação, Apresentação).

### `Domain/Interfaces/IEstadoSessao.cs`
```
using SeiPossoEnsinar.Domain.Entities;
namespace SeiPossoEnsinar.Domain.Interfaces
{
    public interface IEstadoSessao
    {
        void Aceitar(Sessao sessao);
        void Recusar(Sessao sessao);
        void Cancelar(Sessao sessao);
        void Concluir(Sessao sessao);
        void Avaliar(Sessao sessao, string comentario, int nota);
        void EnviarMensagem(Sessao sessao, string mensagem);
    }
}
```

### `Domain/States/EstadoAgendada.cs`

```
using SeiPossoEnsinar.Domain.Interfaces;
using SeiPossoEnsinar.Domain.Entities;
using System;

namespace SeiPossoEnsinar.Domain.States
{
    public class EstadoAgendada : IEstadoSessao
    {
        public void Concluir(Sessao sessao)
        {
            Console.WriteLine("Sessão concluída.");
            sessao.MudarEstado(new EstadoConcluida());
        }

        public void Cancelar(Sessao sessao)
        {
            Console.WriteLine("Sessão agendada foi cancelada.");
            sessao.MudarEstado(new EstadoCancelada());
        }

        public void EnviarMensagem(Sessao sessao, string mensagem)
        {
            Console.WriteLine($"Chat (Agendada): {mensagem}");
        }

        public void Aceitar(Sessao s) => throw new InvalidOperationException($"Não é possível 'Aceitar' uma sessão que já está 'Agendada'.");
        public void Recusar(Sessao s) => throw new InvalidOperationException($"Não é possível 'Recusar' uma sessão que já está 'Agendada'.");
        public void Avaliar(Sessao s, string c, int n) => throw new InvalidOperationException($"Não é possível 'Avaliar' uma sessão que já está 'Agendada'.");
    }
}
```

### `Domain/States/EstadoCancelada.cs`

```
using SeiPossoEnsinar.Domain.Interfaces;
using SeiPossoEnsinar.Domain.Entities;
using System;

namespace SeiPossoEnsinar.Domain.States
{
    public class EstadoCancelada : IEstadoSessao
    {
        public void Aceitar(Sessao s) => throw new InvalidOperationException($"Não é possível 'Aceitar' uma sessão que já foi 'Cancelada'.");
        public void Recusar(Sessao s) => throw new InvalidOperationException($"Não é possível 'Recusar' uma sessão que já foi 'Cancelada'.");
        public void Cancelar(Sessao s) => throw new InvalidOperationException($"Não é possível 'Cancelar' uma sessão que já foi 'Cancelada'.");
        public void Concluir(Sessao s) => throw new InvalidOperationException($"Não é possível 'Concluir' uma sessão que já foi 'Cancelada'.");
        public void Avaliar(Sessao s, string c, int n) => throw new InvalidOperationException($"Não é possível 'Avaliar' uma sessão que já foi 'Cancelada'.");
        public void EnviarMensagem(Sessao s, string m) => throw new InvalidOperationException($"Não é possível 'Enviar Mensagem' uma sessão que já foi 'Cancelada'.");
    }
}
```

### `Domain/States/EstadoConcluida.cs`

```
using SeiPossoEnsinar.Domain.Interfaces;
using SeiPossoEnsinar.Domain.Entities;
using System;

namespace SeiPossoEnsinar.Domain.States
{
    public class EstadoConcluida : IEstadoSessao
    {
        public void Avaliar(Sessao sessao, string comentario, int nota)
        {
            Console.WriteLine($"Sessão avaliada: Nota {nota}, Comentário: {comentario}");
        }

        public void Aceitar(Sessao s) => throw new InvalidOperationException($"Não é possível 'Aceitar' uma sessão que já foi 'Concluída'.");
        public void Recusar(Sessao s) => throw new InvalidOperationException($"Não é possível 'Recusar' uma sessão que já foi 'Concluída'.");
        public void Cancelar(Sessao s) => throw new InvalidOperationException($"Não é possível 'Cancelar' uma sessão que já foi 'Concluída'.");
        public void Concluir(Sessao s) => throw new InvalidOperationException($"Não é possível 'Concluir' uma sessão que já foi 'Concluída'.");
        
        public void EnviarMensagem(Sessao s, string m) => throw new InvalidOperationException($"Não é possível 'Enviar Mensagem' uma sessão que já foi 'Concluída'.");
    }
}
```

### `Domain/States/EstadoSolicitada.cs`

```
using SeiPossoEnsinar.Domain.Interfaces;
using SeiPossoEnsinar.Domain.Entities;
using System;

namespace SeiPossoEnsinar.Domain.States
{
    public class EstadoSolicitada : IEstadoSessao
    {
        public void Aceitar(Sessao sessao)
        {
            Console.WriteLine("Sessão aceita pelo monitor.");
            sessao.MudarEstado(new EstadoAgendada());
        }

        public void Recusar(Sessao sessao)
        {
            Console.WriteLine("Sessão recusada pelo monitor.");
            sessao.MudarEstado(new EstadoCancelada());
        }

        public void Cancelar(Sessao sessao)
        {
            Console.WriteLine("Solicitação cancelada pelo aluno.");
            sessao.MudarEstado(new EstadoCancelada());
        }

        public void Concluir(Sessao s) => throw new InvalidOperationException($"Não é possível 'Concluir' uma sessão que está 'Solicitada'.");
        public void Avaliar(Sessao s, string c, int n) => throw new InvalidOperationException($"Não é possível 'Avaliar' uma sessão que está 'Solicitada'.");
        public void EnviarMensagem(Sessao s, string m) => throw new InvalidOperationException($"Não é possível 'Enviar Mensagem' uma sessão que está 'Solicitada'.");
    }
}
```
### `Domain/Entities/Sessao.cs`

```
using SeiPossoEnsinar.Domain.Interfaces;
using SeiPossoEnsinar.Domain.States;
using System; 

namespace SeiPossoEnsinar.Domain.Entities
{
    public class Sessao
    {
        private IEstadoSessao _estado;
        public Sessao()
        {
            this._estado = new EstadoSolicitada();
        }
        public void MudarEstado(IEstadoSessao novoEstado)
        {
            this._estado = novoEstado;
        }
        public IEstadoSessao GetEstado() => _estado;
        public void Aceitar() => _estado.Aceitar(this);
        public void Recusar() => _estado.Recusar(this);
        public void Cancelar() => _estado.Cancelar(this);
        public void Concluir() => _estado.Concluir(this);
        public void Avaliar(string c, int n) => _estado.Avaliar(this, c, n);
        public void EnviarMensagem(string msg) => _estado.EnviarMensagem(this, msg);
    }
}
```

### `Application/Services/SessaoService.cs`

```
using SeiPossoEnsinar.Domain.Entities; 
using System; 

namespace SeiPossoEnsinar.Application.Services
{
    public class SessaoService
    {

        public void AceitarSolicitacao(Guid sessaoId)
        {
            Sessao sessao = new Sessao(); // Simulação
            try
            {
                sessao.Aceitar();
            }
            catch (InvalidOperationException ex)
            {
                Console.WriteLine(ex.Message);
                return;
            }
        }
    }
}
```

#### Informações adicionais

- [Código rodando](https://drive.google.com/file/d/1KE2oCYvQox0f16YhKX6QQob4GTeqrIJd/view?usp=sharing)<br>
  Participantes: Atyrson Souto
- [Repositório do Código]()


## Conclusão

O padrão **State** mostra-se uma ferramenta fundamental no projeto para gerenciar o complexo ciclo de vida das sessões de monitoria. Ao isolar o comportamento específico de cada estado em classes independentes, alinhadas aos princípios SOLID, conseguimos:

* **Reduzir drasticamente** o uso de condicionais (`if`/`switch`) na entidade `Sessao`.
* **Melhorar a organização** e coesão do código, tornando-o mais limpo.
* **Facilitar a extensão** futura com novos estados, sem impacto no código existente.
* **Garantir baixo acoplamento** entre a entidade `Sessao` (Contexto) e as regras de negócio de seus estados.

## Bibliografia
> State - Padrão Comportamental. Refactoring Guru. Disponível em: https://refactoring.guru/design-patterns/state. Acesso em: 15 out. 2025.

> SERRANO, Milene. 10d - Video-Aula - DSW - GoFs - Comportamentais - Demais Padrões - Visões. 1 vídeo (aula de Arquitetura e Desenho de Software). Disponível em: [Link da aula da professora](https://unbbr-my.sharepoint.com/personal/mileneserrano_unb_br/_layouts/15/stream.aspx?id=%2Fpersonal%2Fmileneserrano%5Funb%5Fbr%2FDocuments%2FArqDSW%20%2D%20V%C3%ADdeosOriginais%2F10d%20%2D%20Video%2DAula%20%2D%20DSW%20%2D%20GoFs%20%2D%20Comportamentais%20%2D%20Demais%2Emp4&ga=1&referrer=StreamWebApp%2EWeb&referrerScenario=AddressBarCopied%2Eview%2Edb489679%2Dfd09%2D4c18%2D924e%2D1cf833920005). Acesso em: 15 out. 2025.

> State Design Pattern. SourceMaking. Disponível em: https://sourcemaking.com/design_patterns/state. Acesso em: 16 out. 2025.

## Histórico de Versões

| Versão | Data | Descrição | Autor(es) | Revisor(es) |
| :---: | :---: | :--- | :--- | :--- |
| 1.0 | 23/10/2025 | Criação do documento, introdução e modelagem do Gof State. | Yan Lucas Guimarães | Atyrson Souto, Pedro Tulio |
| 1.1 | 23/10/2025 | Adição do Diagrama UML e Conclusão. | Yan Lucas Guimarães | Victor Camara, Bruno Cruz |
| 1.2 | 24/10/2025 | Vinculação da Análise de Domínio com os Casos de Uso (UCs). | Yan Lucas Guimarães | |
